# SwiftyShield

<p align="center">
  <strong>简体中文</strong> | <a href="../README.md">English</a>
</p>

<p align="center">
  <strong>专业的 Swift 代码混淆工具</strong>
</p>

<p align="center">
  通过重命名代码标识符来混淆 Swift 源码，在不改变代码逻辑的前提下保护您的源代码<br>
  已通过 <strong>100+ SDK</strong> 的严格验证，无论您的代码多复杂，都能精准识别并完美混淆<br>
  支持大型项目、复杂依赖关系，为您的代码提供企业级安全保护<br>
  <strong>经过生产环境实战检验，您可以放心在正式项目中使用</strong>
</p>

---

## 📥 下载

**官方网站**: [https://www.swiftyshield.com](https://www.swiftyshield.com)

前往官网下载最新版本的 SwiftyShield

> ✅ **已通过 Apple 公证** - 应用已通过 Apple 官方公证，确保安全性和可靠性

---

## 📺 演示视频

[👉 点击此处观看演示视频](https://erjntqiotojkxtyrhscz.supabase.co/storage/v1/object/public/Demo/swiftyshield-demo.mp4)

---

## ✨ 产品功能

### 🔐 安全的源码保护
- **智能混淆**: 仅改变代码名称，不影响代码逻辑
- **全局声明混淆**: 混淆类名、方法名、属性名等全局标识符
- **临时变量混淆**: 可选的临时变量混淆功能
- **增量混淆**: 支持基于历史记录的增量混淆，旧代码沿用历史映射，仅混淆新增代码

### 🎯 灵活的配置选项
- **模块选择**: 自由选择需要混淆的模块
- **忽略列表**: 支持配置忽略的协议名称和变量名
- **编译模式**: 支持 Debug 和 Release 两种编译模式
- **关联模块智能处理**: 自动处理模块间的依赖关系

### 📊 完整的记录管理
- **混淆历史**: 本地保存所有混淆操作记录
- **详细信息**: 记录混淆时长、混淆数量、模块信息等
- **导入导出**: 支持混淆记录的 JSON 导入导出
- **快速复用**: 基于历史记录进行增量混淆

### 👤 账户系统
- **Apple ID 登录**: 使用 Apple ID 安全登录
- **Premium 会员**: 升级 Premium 解锁更多功能
- **个性化定制**: Premium 用户可定制混淆功能

---

## 🚀 使用说明

### 第一步：登录账户

1. 打开 SwiftyShield 应用
2. 点击 **Apple 登录** 按钮
3. 使用您的 Apple ID 完成登录验证

> 💡 提示：需要登录后才能使用混淆功能

### 第二步：选择项目

1. 在首页点击选择 `.xcworkspace` 或 `.xcodeproj` 文件
2. 选择编译模式：
   - **Debug 模式**：开发调试使用
   - **Release 模式**：发布版本使用
3. 点击开始编译

### 第三步：选择模块

编译成功后，系统将自动进入模块选择页面：

1. 查看所有可混淆的模块列表
2. 点击模块可展开查看包含的文件列表
3. 选择需要混淆的模块（支持全选/全不选）
4. 系统会自动处理模块间的关联关系
5. 点击 **下一步** 继续

> 📌 注意：如果模块 A 被模块 B 关联，选择 A 时会自动勾选 B

### 第四步：配置混淆选项

在混淆配置页面设置以下选项：

#### 1. 临时变量混淆
- 开启或关闭临时变量混淆功能
- 点击"展示例子"查看混淆效果示例

#### 2. 忽略协议名称
- 添加不需要混淆的协议名称
- 支持添加多个协议名称
- 输入限制：仅支持英文字符，不超过 40 个字符

#### 3. 忽略变量名称
- 添加不需要混淆的变量名称
- 支持添加多个变量名称
- 输入限制：仅支持英文字符，不超过 40 个字符

配置完成后点击 **下一步**

### 第五步：选择父混淆记录（可选）

如果当前项目存在历史混淆记录，系统会询问是否基于历史记录进行增量混淆：

- **选择父记录**：新代码将被混淆，旧代码沿用历史映射
- **不选择**：执行全新混淆，所有代码重新生成混淆映射

> 💡 提示：增量混淆可以保持代码的一致性，避免已混淆代码被重复修改

### 第六步：开始混淆

混淆过程中会实时显示：

- **Global Declarations 进度**：全局声明混淆进度
- **Temp Declarations 进度**：临时变量混淆进度（如果开启）
- **混淆日志**：实时输出混淆操作日志

混淆过程中可以点击 **停止混淆** 按钮中断操作

混淆完成后，点击 **下一步** 查看结果

### 第七步：查看历史记录

在首页点击 **混淆历史记录** 入口，可以：

- 查看所有混淆操作记录
- 按 Scheme 分组展示
- 查看详细的混淆信息（时长、数量、模块等）
- 导出混淆记录为 JSON 文件
- 复制 JSON 到剪贴板
- 删除不需要的记录
- 导入历史记录

> ⚠️ 重要：所有混淆记录保存在本地，请定期备份

---

## 📝 版本更新记录

### v1.1.6
- 新增明文字符串的拆分和混淆功能
- ⚠️ **定制版本**：此版本不公开下载，如有需要请联系

### v1.1.5
- 优化功能：忽略未参与编译代码的混淆

### v1.1.4
- 优化 sourcekit 强行 indexing 没有参与编译代码而导致的崩溃

---

## 📞 联系我们

如有任何问题或建议，欢迎通过以下方式联系我们：

- **联系邮箱**: swiftyshield@outlook.com

---

## ❓ 常见问题

### Q: 混淆会影响代码功能吗？
A: 不会。SwiftyShield 只改变代码的标识符名称，不改变代码逻辑，因此不会影响代码功能。

### Q: 混淆后的代码可以还原吗？
A: 不可以。因为无法确定您是否对混淆后的代码做出了改动，所以无法自动还原。我们建议使用 Git 来管理代码版本，在混淆前保留原始代码。

### Q: 如何对比混淆前后的代码关系？
A: 混淆记录中包含了所有的映射关系可供查看。您可以在混淆历史记录中查看混淆前后标识符的详细对应关系。

### Q: 支持哪些 Swift 版本？
A: 支持 Swift 5.0 及以上版本。

### Q: 可以混淆第三方库吗？
A: 可以，但建议仅混淆您自己的代码。

### Q: Payment ID 在哪里获取？
A: 完成支付后，Payment ID 会发送到您的注册邮箱，请注意查收（可能需要几分钟）。

### Q: 如果属性名称映射服务端字段，如何忽略存在映射关系的属性？
A: 如果你的 Model 遵循 `Codable` 协议，则不需要额外处理，SwiftyShield 会自动处理。否则，你需要自定义一个 protocol，在混淆之前将该 protocol 的名字添加到忽略协议列表中，这样就不会破坏映射关系。
